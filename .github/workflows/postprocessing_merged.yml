name: Post-processing

# don't limit to main branch
# consider maintenance branch
on:
  push:
    branches:
      - 'release-branch.**'
      - main
    paths-ignore:
      - '.github/**'
      - LICENSE
      - README.md
      - '.gitignore'

concurrency:
  group: ${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

jobs:
  release-binary-files:
    strategy:
      matrix:
        os:
          - macos-13
        #   - macos-latest
        #   - ubuntu-24.04
        #   - ubuntu-24.04-arm
    runs-on: ${{matrix.os}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Check out LLGo (for Python packages)
        uses: actions/checkout@v4
        with:
          repository: '1351914167/llgo'
          path: .llgo
          ref: get_pip
      - name: Check out LLPyg (for Python packages)
        uses: actions/checkout@v4
        with:
          repository: 'toaction/llpyg'
          path: .llpyg
          ref: feat/v1
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.24.x
      - name: Set up Tool
        run: |
          git clone https://github.com/PengPengPeng717/llpkgstore.git
          cd llpkgstore
          git checkout version
          go build -o llpkgstore ./cmd/llpkgstore
          sudo mv llpkgstore /usr/local/bin/
      - name: Install dependencies (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          # 先卸载可能冲突的cmake
          brew uninstall cmake --ignore-dependencies || true
          # 安装依赖包
          brew install llvm@19 bdw-gc openssl libffi libuv cmake conan lld@19
          brew link --force libffi
          echo "$(brew --prefix llvm@19)/bin" >> $GITHUB_PATH
          echo "$(brew --prefix lld@19)/bin" >> $GITHUB_PATH
          echo "Dependencies installed for both Python and C++ packages"
    #   - name: Install dependencies (Ubuntu)
    #     if: startsWith(matrix.os, 'ubuntu')
    #     run: |
    #       sudo apt-get update
    #       sudo apt-get install -y cmake python3 python3-pip pkg-config
    #       python3 -m pip install conan
    #       echo "Dependencies installed for both Python and C++ packages"
      - name: Setup LLGo (for Python packages)
        working-directory: .llgo
        run: |
          go install -v ./cmd/...
          export LLGO_ROOT=$PWD
          echo "LLGO_ROOT=$LLGO_ROOT" >> $GITHUB_ENV
          echo "LLGO_RPATH_CHANGE=ON" >> $GITHUB_ENV
      - name: Set up Python environment (for Python packages)
        run: |
          echo "GOTOOLCHAIN=go1.24.5" >> $GITHUB_ENV
          # 保存原始Python环境变量
          echo "ORIGINAL_PYTHONHOME=$PYTHONHOME" >> $GITHUB_ENV
          echo "ORIGINAL_PATH=$PATH" >> $GITHUB_ENV
          # 设置LLGo Python环境
          export PYTHONHOME=$LLGO_ROOT/python
          export PATH=$PYTHONHOME/bin:$PATH
          export DYLD_LIBRARY_PATH=$PYTHONHOME/lib
          export PKG_CONFIG_PATH=$PYTHONHOME/lib/pkgconfig
          echo "PYTHONHOME=$PYTHONHOME" >> $GITHUB_ENV
          echo "PATH=$PATH" >> $GITHUB_ENV
          echo "DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
      - name: Setup LLPyg (for Python packages)
        working-directory: .llpyg
        run: |
          cd _xtool
          llgo install ./...
          cd ..
          go install -v ./cmd/...
      - name: Set up Conan (for C++ packages)
        run: |
          # 临时恢复系统Python环境用于Conan
          if [ -n "$ORIGINAL_PYTHONHOME" ]; then
            export PYTHONHOME="$ORIGINAL_PYTHONHOME"
          else
            unset PYTHONHOME
          fi
          # 恢复原始PATH，但保留必要的工具路径
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"
          echo "Using system Python for Conan: $(which python3 || which python)"
          conan profile detect
      - name: Run release process
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: llpkgstore release
      - name: Upload binary file to artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{env.BIN_FILENAME || 'llpkg-binary'}}
          path: ${{env.BIN_PATH || './dist'}}
          retention-days: 1
  post-processing:
    runs-on: ubuntu-latest
    needs: [release-binary-files]
    steps:
      - name: Checkout current branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref_name }}
          path: .main
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.24.x
      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
      - name: Configure GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
          gh auth status
      - name: Set up Tool
        run: |
          git clone https://github.com/PengPengPeng717/llpkgstore.git
          cd llpkgstore
          git checkout version
          go build -o llpkgstore ./cmd/llpkgstore
          sudo mv llpkgstore /usr/local/bin/
      - name: Checkout to website (for C++ packages)
        uses: actions/checkout@v4
        with:
          ref: website
          path: .website
      - name: Copy llpkgstore.json to root (for C++ packages)
        continue-on-error: true
        run: |
          ls .website .website/public
          cp .website/public/llpkgstore.json .main
          rm -rf .website
      - name: Detect package types and process accordingly
        working-directory: .main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Current branch: $(git branch --show-current)"
          echo "Current commit: $(git log -1 --pretty=format:%s)"
          
          # 从 commit 消息中提取源分支名
          COMMIT_MSG=$(git log -1 --pretty=format:%s)
          if [[ $COMMIT_MSG =~ Merge\ pull\ request.*from\ PengPengPeng717/([^[:space:]]+) ]]; then
            SOURCE_BRANCH="${BASH_REMATCH[1]}"
            echo "Detected source branch from commit message: $SOURCE_BRANCH"
            
            # 切换到源分支
            echo "Switching to source branch: $SOURCE_BRANCH"
            git fetch origin $SOURCE_BRANCH:$SOURCE_BRANCH
            git checkout $SOURCE_BRANCH
            echo "Switched to branch: $(git branch --show-current)"
          else
            echo "Could not detect source branch from commit message: $COMMIT_MSG"
          fi
          
          echo "Final branch: $(git branch --show-current)"
          echo "Final commit: $(git log -1 --pretty=format:%s)"
          
          # 调试信息：打印当前路径和文件结构
          echo "=== Debug Information ==="
          echo "Current working directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo "=== End Debug ==="
          
          # 获取当前提交中修改的包目录
          echo "=== Finding modified packages ==="
          MODIFIED_PACKAGES=""
          
          # 检查是否是合并提交
          if git log -1 --pretty=format:%P | grep -q " "; then
            echo "This is a merge commit, checking changes from merge base"
            # 对于合并提交，比较与main分支的差异
            BASE_COMMIT=$(git merge-base HEAD main)
            echo "Base commit: $BASE_COMMIT"
            MODIFIED_PACKAGES=$(git diff --name-only $BASE_COMMIT HEAD | grep -E '^[^/]+/' | cut -d'/' -f1 | sort -u)
          else
            echo "This is a regular commit, checking changes from previous commit"
            # 对于普通提交，比较与前一个提交的差异
            MODIFIED_PACKAGES=$(git diff --name-only HEAD~1 HEAD | grep -E '^[^/]+/' | cut -d'/' -f1 | sort -u)
          fi
          
          echo "Modified packages: $MODIFIED_PACKAGES"
          
          if [ -z "$MODIFIED_PACKAGES" ]; then
            echo "No package directories were modified in this commit"
            echo "Checking if this is a release commit by looking for 'Release-as:' in commit message"
            COMMIT_MSG=$(git log -1 --pretty=format:%s)
            if [[ $COMMIT_MSG =~ Release-as:\ ([^/]+)/ ]]; then
              PACKAGE_NAME="${BASH_REMATCH[1]}"
              echo "Found release commit for package: $PACKAGE_NAME"
              # 验证包目录是否存在（检查根目录和Python_package目录）
              if [ -d "$PACKAGE_NAME" ] && [ -f "$PACKAGE_NAME/llpkg.cfg" ]; then
                MODIFIED_PACKAGES="$PACKAGE_NAME"
                echo "Package directory $PACKAGE_NAME exists and is valid in root"
              elif [ -d "Python_package/$PACKAGE_NAME" ] && [ -f "Python_package/$PACKAGE_NAME/llpkg.cfg" ]; then
                MODIFIED_PACKAGES="$PACKAGE_NAME"
                echo "Package directory $PACKAGE_NAME exists and is valid in Python_package"
              else
                echo "Package directory $PACKAGE_NAME not found or missing llpkg.cfg"
                echo "Available directories in root:"
                ls -la | grep "^d" | awk '{print $9}' | grep -v "^\.$\|^\.\.$\|^\.git$\|^\.github$\|^public$\|^Python_package$"
                echo "Available directories in Python_package:"
                if [ -d "Python_package" ]; then
                  ls -la Python_package/ | grep "^d" | awk '{print $9}' | grep -v "^\.$\|^\.\.$"
                else
                  echo "Python_package directory does not exist"
                fi
                exit 0
              fi
            else
              echo "No release commit detected, skipping postprocessing"
              exit 0
            fi
          fi
          
          # 过滤掉非包目录（如Python_package、.github等）
          echo "=== Filtering package directories ==="
          FILTERED_PACKAGES=""
          for package in $MODIFIED_PACKAGES; do
            # 跳过已知的非包目录
            if [[ "$package" =~ ^(Python_package|\.github|\.git|public|\.DS_Store)$ ]]; then
              echo "Skipping non-package directory: $package"
              continue
            fi
            
            # 检查是否是有效的包目录
            if [ -d "$package" ] && [ -f "$package/llpkg.cfg" ]; then
              FILTERED_PACKAGES="$FILTERED_PACKAGES $package"
              echo "Valid package directory: $package"
            else
              echo "Invalid package directory (missing llpkg.cfg): $package"
            fi
          done
          
          MODIFIED_PACKAGES="$FILTERED_PACKAGES"
          echo "Filtered packages: $MODIFIED_PACKAGES"
          
          # 初始化包类型数组
          PYTHON_PACKAGES=""
          CPP_PACKAGES=""
          
          # 第一阶段：扫描所有修改的包，检测包类型
          echo "=== Scanning package types ==="
          for package in $MODIFIED_PACKAGES; do
            # 检查包目录位置（根目录或Python_package目录）
            PACKAGE_DIR=""
            if [ -d "$package" ] && [ -f "$package/llpkg.cfg" ]; then
              PACKAGE_DIR="$package"
              echo "Found package $package in root directory"
            elif [ -d "Python_package/$package" ] && [ -f "Python_package/$package/llpkg.cfg" ]; then
              PACKAGE_DIR="Python_package/$package"
              echo "Found package $package in Python_package directory"
            fi
            
            if [ -n "$PACKAGE_DIR" ]; then
              echo "Checking package: $package (at $PACKAGE_DIR)"
              
              # 检查llpkg.cfg中的type字段
              PACKAGE_TYPE=$(grep -o '"type":\s*"[^"]*"' "$PACKAGE_DIR/llpkg.cfg" | cut -d'"' -f4 || echo "")
              echo "Package $package type detected: ${PACKAGE_TYPE:-'C++ (default)'}"
              
              if [ "$PACKAGE_TYPE" = "python" ]; then
                PYTHON_PACKAGES="$PYTHON_PACKAGES $package"
                echo "Added $package to Python packages list"
              else
                CPP_PACKAGES="$CPP_PACKAGES $package"
                echo "Added $package to C++ packages list"
              fi
            else
              echo "Package directory $package not found or missing llpkg.cfg"
            fi
          done
          
          echo "=== Package Type Summary ==="
          echo "Python packages: $PYTHON_PACKAGES"
          echo "C++ packages: $CPP_PACKAGES"
          
          # 第二阶段：根据包类型执行不同的处理逻辑
          if [ -n "$PYTHON_PACKAGES" ]; then
            echo "=== Processing Python packages ==="
            for package in $PYTHON_PACKAGES; do
              echo "Processing Python package: $package"
              
              # 确定包目录位置
              PACKAGE_DIR=""
              if [ -d "$package" ] && [ -f "$package/llpkg.cfg" ]; then
                PACKAGE_DIR="$package"
              elif [ -d "Python_package/$package" ] && [ -f "Python_package/$package/llpkg.cfg" ]; then
                PACKAGE_DIR="Python_package/$package"
              fi
              
              if [ -n "$PACKAGE_DIR" ]; then
                echo "Processing package from directory: $PACKAGE_DIR"
                echo "=== Before llpkgstore postprocessing ==="
                echo "Current directory: $(pwd)"
                echo "Directory contents:"
                ls -la
                echo "About to run: llpkgstore postprocessing from root directory"
                echo "=== End Before ==="
                llpkgstore postprocessing
                echo "=== After llpkgstore postprocessing ==="
                echo "Current directory: $(pwd)"
                echo "Directory contents:"
                ls -la
                echo "=== End After ==="
                
                # 为Python包创建Python_package目录结构
                echo "Creating Python_package directory structure"
                mkdir -p Python_package
                if [ -f "llpkgstore.json" ]; then
                  cp llpkgstore.json Python_package/
                  echo "Copied llpkgstore.json to Python_package/"
                fi
                
                # 为Python包创建专门的目录结构
                echo "Setting up Python package directory structure"
                mkdir -p Python_package/$package
                if [ -d "$PACKAGE_DIR" ]; then
                  cp -r "$PACKAGE_DIR"/* Python_package/$package/ 2>/dev/null || echo "No files to copy for $package"
                  echo "Copied $package files to Python_package/$package/"
                fi
              else
                echo "Package directory $package not found, skipping processing"
              fi
            done
          fi
          
          if [ -n "$CPP_PACKAGES" ]; then
            echo "=== Processing C++ packages ==="
            for package in $CPP_PACKAGES; do
              echo "Processing C++ package: $package"
              echo "=== Before llpkgstore postprocessing ==="
              echo "Current directory: $(pwd)"
              echo "Directory contents:"
              ls -la
              echo "About to run: llpkgstore postprocessing from root directory"
              echo "=== End Before ==="
              llpkgstore postprocessing
              echo "=== After llpkgstore postprocessing ==="
              echo "Current directory: $(pwd)"
              echo "Directory contents:"
              ls -la
              echo "=== End After ==="
              
              # C++包直接上传到llpkg目录下（原有逻辑）
              echo "C++ package processed, files will be uploaded to llpkg directory"
            done
          fi
      - name: Checkout website branch (for C++ packages)
        uses: actions/checkout@v4
        with:
            ref: website
            path: .website
      - name: Move llpkgstore.json to website (for C++ packages)
        run: |
          if [ -f ".main/llpkgstore.json" ]; then
            mv .main/llpkgstore.json .website/public
            echo "Moved llpkgstore.json to website for C++ packages"
          else
            echo "No llpkgstore.json found for C++ packages"
          fi
    #   - name: Commit and push changes (for C++ packages)
    #     working-directory: .website
    #     run: |
    #         git config --local user.email "action@github.com"
    #         git config --local user.name "GitHub Action"
    #         git add public/llpkgstore.json
    #         git commit -m "Update llpkgstore.json" || echo "No changes to commit"
    #         git push
      - name: Handle Python packages upload
        working-directory: .main
        run: |
          if [ -d "Python_package" ]; then
            echo "=== Processing Python packages for upload ==="
            echo "Python_package directory contents:"
            ls -la Python_package/
            
            # 检查是否有Python包需要上传
            if [ -f "Python_package/llpkgstore.json" ]; then
              echo "Found Python package llpkgstore.json"
              
              # 这里可以添加Python包的上传逻辑
              # 例如：上传到专门的Python包存储位置
              echo "Python packages processed and ready for upload"
              echo "Python package structure:"
              find Python_package/ -type f -name "*.json" -o -name "*.go" -o -name "*.cfg" | head -10
            else
              echo "No Python packages found to upload"
            fi
          else
            echo "No Python_package directory found"
          fi
#   build-and-upload:
#     runs-on: ubuntu-latest
#     needs: [post-processing]
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4
#         with:
#           ref: website
#       - name: Setup Node.js
#         uses: actions/setup-node@v3
#         with:
#           node-version: 23.8.0
#       - run: corepack enable
#       - name: Install Dependencies
#         uses: borales/actions-yarn@v4
#         with:
#           cmd: install
#       - name: Build
#         uses: borales/actions-yarn@v4
#         with:
#           cmd: build
#       - name: Upload artifact
#         uses: actions/upload-pages-artifact@v3
#         with:
#           path: 'dist'
#   deploy:
#     needs: build-and-upload
#     runs-on: ubuntu-latest
#     permissions:
#       pages: write
#       id-token: write
#     steps:
#       - name: Deploy to GitHub Pages
#         id: deployment
#         uses: actions/deploy-pages@v4
